import { notStrictEqual, ok, strictEqual } from "assert";
import { EOL } from "os";
import { TempDirectory, TempFile } from "@manuth/temp-files";
import { load } from "cheerio";
import dedent = require("dedent");
import { readFile, writeFile } from "fs-extra";
import MultiRange from "multi-integer-range";
import { dirname, join, parse, resolve } from "upath";
import { commands, ConfigurationTarget, TextDocument, Uri, window, workspace } from "vscode";
import { Converter } from "../../../../Conversion/Converter";
import { MarkdownConverterExtension } from "../../../../MarkdownConverterExtension";
import { ISettings } from "../../../../Properties/ISettings";
import { Margin } from "../../../../System/Documents/Margin";
import { PaperOrientation } from "../../../../System/Documents/PaperOrientation";
import { StandardizedFormatType } from "../../../../System/Documents/StandardizedFormatType";
import { StandardizedPaperFormat } from "../../../../System/Documents/StandardizedPaperFormat";
import { ConversionRunner } from "../../../../System/Tasks/ConversionRunner";
import { ITestContext } from "../../../ITestContext";
import { SubstitutionTester } from "../../../SubstitutionTester";

/**
 * Registers tests for the `ConversionRunner` class.
 *
 * @param context
 * The test-context.
 */
export function ConversionRunnerTests(context: ITestContext<ISettings>): void
{
    suite(
        "ConversionRunner",
        () =>
        {
            let mdFile: TempFile;
            let destinationFile: TempFile;
            let Convert: () => Promise<void>;

            /**
             * Provides an implementation of the `ConversionRunner` class for testing.
             */
            class TestConversionRunner extends ConversionRunner
            {
                /**
                 * Initializes a new instance of the `TestConversionRunner` class.
                 */
                public constructor()
                {
                    super({ VSCodeParser: {} } as MarkdownConverterExtension);
                }

                /**
                 * @inheritdoc
                 *
                 * @param workspaceRoot
                 * The path to the root of the workspace of the document.
                 *
                 * @param document
                 * The document to convert.
                 *
                 * @returns
                 * A converter generated by the settings.
                 */
                public LoadConverter(workspaceRoot: string, document: TextDocument): Promise<Converter>
                {
                    return super.LoadConverter(workspaceRoot, document);
                }
            }

            suiteSetup(
                async () =>
                {
                    mdFile = new TempFile(
                        {
                            Suffix: ".md"
                        });

                    destinationFile = new TempFile(
                        {
                            Suffix: ".html"
                        });

                    await window.showTextDocument(Uri.file(mdFile.FullName));

                    Convert = async () =>
                    {
                        await commands.executeCommand("workbench.action.closeAllGroups");
                        await window.showTextDocument(Uri.file(mdFile.FullName));
                        await commands.executeCommand("markdown.showPreview");
                        await commands.executeCommand("workbench.action.closeAllGroups");
                        await window.showTextDocument(Uri.file(mdFile.FullName));
                        await commands.executeCommand("workbench.action.files.revert");
                        await commands.executeCommand("workbench.action.focusFirstEditorGroup");
                        await new Promise((resolve) => setTimeout(resolve, 100));
                        await commands.executeCommand("markdownConverter.Convert");
                    };
                });

            suiteTeardown(
                async function()
                {
                    this.timeout(5 * 1000);
                    mdFile.Dispose();
                    destinationFile.Dispose();
                });

            setup(
                async function()
                {
                    this.slow(2 * 1000);
                    this.timeout(8 * 1000);
                    await writeFile(mdFile.FullName, "");
                    context.Settings.ConversionType = ["HTML"];
                    context.Settings.DestinationPattern = destinationFile.FullName;
                    context.Settings["Parser.SystemParserEnabled"] = false;
                });

            suite(
                "LoadParser()",
                () =>
                {
                    test(
                        "Checking whether the system-parser is used if `markdownConverter.Parser.SystemParserEnabled` is true…",
                        async function()
                        {
                            this.slow(6.5 * 1000);
                            this.timeout(26 * 1000);
                            let firstResult: string;
                            let secondResult: string;
                            let lineBreakSetting = "markdown.preview.breaks";
                            let config = workspace.getConfiguration(undefined, workspace.workspaceFolders[0]);
                            await writeFile(mdFile.FullName, "line1" + EOL + "line2");
                            context.Settings["Parser.SystemParserEnabled"] = true;
                            await config.update(lineBreakSetting, true, ConfigurationTarget.Workspace);
                            await Convert();
                            firstResult = (await readFile(destinationFile.FullName)).toString();
                            await config.update(lineBreakSetting, false, ConfigurationTarget.Workspace);
                            await Convert();
                            secondResult = (await readFile(destinationFile.FullName)).toString();
                            notStrictEqual(firstResult, secondResult);
                        });

                    test(
                        "Checking whether the system-parser is disabled if `markdownConverter.Parser.SystemParserEnabled` is false…",
                        async function()
                        {
                            this.slow(2.5 * 1000);
                            this.timeout(10 * 1000);
                            await writeFile(
                                mdFile.FullName,
                                dedent(
                                    `
                                    <b>test</b>
                                    \`\`\`cs
                                    Console.WriteLine("Test")
                                    \`\`\``));

                            await commands.executeCommand("workbench.action.files.revert");
                            context.Settings["Parser.SystemParserEnabled"] = false;
                            await Convert();
                            let result = load((await readFile(destinationFile.FullName)).toString());
                            strictEqual(result("b:contains('test')").length, 1);
                            strictEqual(result("pre.hljs").length, 1);
                        });

                    test(
                        "Checking whether anchors are created correctly…",
                        async function()
                        {
                            this.slow(3 * 1000);
                            this.timeout(12 * 1000);
                            await writeFile(
                                mdFile.FullName,
                                dedent(
                                    `
                                    # Test
                                    # Test`));

                            await commands.executeCommand("workbench.action.files.revert");
                            await Convert();
                            let result = load((await readFile(destinationFile.FullName)).toString());
                            strictEqual(result("#test").length, 1);
                            strictEqual(result("#test-2").length, 1);
                        });

                    test(
                        "Checking whether the toc is applied according to the settings…",
                        async function()
                        {
                            this.slow(3.5 * 1000);
                            this.timeout(14 * 1000);
                            let tocClass = "markdown-converter-toc-test";
                            let levels = new MultiRange([2]).toString();
                            let indicator = "\\[\\[\\s*toc-test\\s*\\]\\]";
                            let listType = "ol";
                            let excludedHeading = "Not Included";
                            let includedHeading = "Included";

                            await writeFile(
                                mdFile.FullName,
                                dedent(
                                    `
                                    # Table of Contents
                                    [[toc-test]]
    
                                    # ${excludedHeading}
                                    ## ${includedHeading}`));

                            context.Settings["Parser.Toc.Enabled"] = true;
                            context.Settings["Parser.Toc.Class"] = tocClass;
                            context.Settings["Parser.Toc.Levels"] = levels;
                            context.Settings["Parser.Toc.Indicator"] = indicator;
                            context.Settings["Parser.Toc.ListType"] = listType;
                            await Convert();
                            let result = load((await readFile(destinationFile.FullName)).toString());
                            strictEqual(result(`.${tocClass}`).length, 1);
                            strictEqual(result('ol li a[href="#included"]').length, 1);
                            strictEqual(result('ol li a[href="#not-included"]').length, 0);
                        });

                    test(
                        "Checking whether checkboxes are rendered…",
                        async function()
                        {
                            this.slow(2.5 * 1000);
                            this.timeout(10 * 1000);
                            await writeFile(
                                mdFile.FullName,
                                dedent(
                                    `
                                    # ToDo's
                                    - [ ] Rob a bank
                                    - [ ] Get rich
                                    - [ ] Buy a new monitor`));

                            await Convert();
                            let result = load((await readFile(destinationFile.FullName)));
                            strictEqual(result('li input[type="checkbox"]').length, 3);
                        });

                    test(
                        "Checking whether emojis are rendered according to the `Parser.EmojiType`-setting…",
                        async function()
                        {
                            this.slow(5.5 * 1000);
                            this.timeout(22 * 1000);
                            let result: cheerio.Root;
                            await writeFile(mdFile.FullName, "**:sparkles:**");
                            await commands.executeCommand("workbench.action.files.revert");
                            context.Settings["Parser.EmojiType"] = "None";
                            await Convert();
                            result = load((await readFile(destinationFile.FullName)).toString());

                            strictEqual(
                                result("b:contains(':sparkles:')").length +
                                result("strong:contains(':sparkles:')").length,
                                1);

                            context.Settings["Parser.EmojiType"] = "GitHub";
                            await Convert();
                            result = load((await readFile(destinationFile.FullName)).toString());
                            strictEqual(result("b img").length + result("strong img").length, 1);
                        });
                });

            suite(
                "LoadConverter(string workspaceRoot, TextDocument document)",
                () =>
                {
                    test(
                        "Checking whether the settings are applied correctly…",
                        async function()
                        {
                            this.slow(4.25 * 1000);
                            this.timeout(17 * 1000);
                            let workspaceRoot = new TempDirectory();
                            let textDocument = await workspace.openTextDocument({ language: "markdown" });
                            let conversionQuality = 78;
                            let attributes = {
                                hello: "world",
                                this: "is a test"
                            };
                            let locale = "en";
                            let dateFormat = "yyyy/MM/dd";
                            let paperFormat: Partial<StandardizedPaperFormat> = {
                                Format: StandardizedFormatType.Tabloid,
                                Orientation: PaperOrientation.Landscape
                            };
                            let margin: Partial<Margin> = {
                                Top: "29cm",
                                Left: "9mm",
                                Bottom: "18cm",
                                Right: "1m"
                            };
                            let templateFile = new TempFile();
                            let highlightStyle = "agate";
                            let styleSheet = new TempFile();
                            let headerFooterEnabled = false;
                            let headerTemplate = "Hello";
                            let footerTemplate = "World";

                            await writeFile(templateFile.FullName, "This is a test template");
                            context.Settings.ConversionQuality = conversionQuality;
                            context.Settings["Document.Attributes"] = attributes;
                            context.Settings.Locale = locale;
                            context.Settings.DateFormat = dateFormat;

                            context.Settings["Document.Paper.PaperFormat"] = {
                                Format: StandardizedFormatType[paperFormat.Format] as any,
                                Orientation: PaperOrientation[paperFormat.Orientation] as any
                            };

                            context.Settings["Document.Paper.Margin"] = margin;
                            context.Settings["Document.Design.Template"] = templateFile.FullName;
                            context.Settings["Document.Design.HighlightStyle"] = highlightStyle;
                            context.Settings["Document.Design.StyleSheets"] = [styleSheet.FullName];
                            context.Settings["Document.HeaderFooterEnabled"] = headerFooterEnabled;
                            context.Settings["Document.HeaderTemplate"] = headerTemplate;
                            context.Settings["Document.FooterTemplate"] = footerTemplate;
                            await Convert();

                            let converter = await new TestConversionRunner().LoadConverter(workspaceRoot.FullName, textDocument);
                            strictEqual(converter.Document.Quality, conversionQuality);

                            for (let key of Object.keys(attributes) as Array<keyof typeof attributes>)
                            {
                                strictEqual(attributes[key], converter.Document.Attributes[key]);
                            }

                            strictEqual(converter.Document.Locale.Name, locale);
                            strictEqual(converter.Document.DateFormat, dateFormat);
                            strictEqual((converter.Document.Paper.Format as StandardizedPaperFormat).Format, paperFormat.Format);
                            strictEqual((converter.Document.Paper.Format as StandardizedPaperFormat).Orientation, paperFormat.Orientation);

                            for (let key of Object.keys(margin) as Array<keyof typeof margin>)
                            {
                                strictEqual(converter.Document.Paper.Margin[key], margin[key]);
                            }

                            strictEqual(converter.Document.Template, (await readFile(templateFile.FullName)).toString());
                            ok(converter.Document.StyleSheets.filter((stylesheet) => stylesheet.includes(highlightStyle)).length > 0);
                            ok(converter.Document.StyleSheets.includes(styleSheet.FullName));
                            strictEqual(converter.Document.HeaderFooterEnabled, headerFooterEnabled);
                            strictEqual(converter.Document.Header.Content, headerTemplate);
                            strictEqual(converter.Document.Footer.Content, footerTemplate);

                            styleSheet.Dispose();
                            templateFile.Dispose();
                            workspaceRoot.Dispose();
                        });

                    test(
                        "Checking whether the header- and footer-template are loaded from a file according to the attributes…",
                        async function()
                        {
                            this.slow(3 * 1000);
                            this.timeout(12 * 1000);
                            let header = "This is a header";
                            let footer = "This is a footer";
                            let headerTemplate = new TempFile();
                            let footerTemplate = new TempFile();
                            await writeFile(headerTemplate.FullName, header);
                            await writeFile(footerTemplate.FullName, footer);

                            await writeFile(
                                mdFile.FullName,
                                dedent(
                                    `
                                    ---
                                    HeaderTemplate: ${headerTemplate.FullName}
                                    FooterTemplate: ${footerTemplate.FullName}
                                    ---`));

                            await Convert();

                            let converter = await new TestConversionRunner().LoadConverter(
                                dirname(mdFile.FullName),
                                await workspace.openTextDocument(mdFile.FullName));

                            strictEqual(converter.Document.Header.Content, header);
                            strictEqual(converter.Document.Footer.Content, footer);
                            headerTemplate.Dispose();
                            footerTemplate.Dispose();
                        });
                });

            suite(
                "Execute(TextDocument document, Progress<IProgressState> progressReporter?, Progress<IConvertedFile> fileReporter?)",
                () =>
                {
                    suite(
                        "Checking whether the `DestinationPattern` is substituted correctly…",
                        () =>
                        {
                            let testFile: TempFile;
                            let tempDir: TempDirectory;
                            let substitutionTester: SubstitutionTester;

                            suiteSetup(
                                async () =>
                                {
                                    testFile = new TempFile(
                                        {
                                            Suffix: ".mkdwn"
                                        });

                                    tempDir = new TempDirectory();
                                    substitutionTester = new SubstitutionTester(await workspace.openTextDocument(Uri.file(testFile.FullName)));
                                });

                            suiteTeardown(
                                () =>
                                {
                                    testFile.Dispose();
                                    tempDir.Dispose();
                                });

                            test(
                                "${basename}",
                                async function()
                                {
                                    this.slow(1.25 * 1000);
                                    this.timeout(5 * 1000);
                                    context.Settings.DestinationPattern = resolve("${basename}");
                                    strictEqual(await substitutionTester.Test(), resolve(parse(testFile.FullName).name));
                                });

                            test(
                                "${extension}",
                                async function()
                                {
                                    this.slow(1.25 * 1000);
                                    this.timeout(5 * 1000);
                                    context.Settings.ConversionType = ["PDF"];
                                    context.Settings.DestinationPattern = resolve("${extension}");
                                    strictEqual(await substitutionTester.Test(), resolve("pdf"));
                                });

                            test(
                                "${filename}",
                                async function()
                                {
                                    this.slow(1.25 * 1000);
                                    this.timeout(5 * 1000);
                                    context.Settings.DestinationPattern = resolve("${filename}");
                                    strictEqual(await substitutionTester.Test(), resolve(parse(testFile.FullName).base));
                                });

                            test(
                                "Checking whether the `DestinationPatterh` is normalized correctly…",
                                async function()
                                {
                                    this.slow(1.25 * 1000);
                                    this.timeout(5 * 1000);
                                    context.Settings.DestinationPattern = join(tempDir.FullName, "/./test/.././///./.");
                                    strictEqual(resolve(Uri.file(await substitutionTester.Test()).fsPath), resolve(Uri.file(tempDir.FullName).fsPath));
                                });
                        });
                });
        });
}
